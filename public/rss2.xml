<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ada 的个人博客主页</title>
    <link>http://adashuai5.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>当然我也在扯淡。。</description>
    <pubDate>Fri, 08 Mar 2019 15:41:00 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Vue 全家桶学习总结</title>
      <link>http://adashuai5.com/2019/02/26/Vue-%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</link>
      <guid>http://adashuai5.com/2019/02/26/Vue-%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</guid>
      <pubDate>Tue, 26 Feb 2019 15:32:17 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Vue&quot;&gt;&lt;a href=&quot;#Vue&quot; class=&quot;headerlink&quot; title=&quot;Vue&quot;&gt;&lt;/a&gt;Vue&lt;/h1&gt;&lt;h2 id=&quot;Vue-js-特性：&quot;&gt;&lt;a href=&quot;#Vue-js-特性：&quot; class=&quot;headerlink&quot; title=&quot;V
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="Vue-js-特性："><a href="#Vue-js-特性：" class="headerlink" title="Vue.js 特性："></a>Vue.js 特性：</h2><p>1.轻量级<br>2.双向数据绑定<br>3.指令<br>4.组件化</p><h2 id="什么是-MVVM"><a href="#什么是-MVVM" class="headerlink" title="什么是 MVVM"></a>什么是 MVVM</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MVC =&gt; MVP =&gt; MVVM</span><br><span class="line">// 视图层和数据层的双向绑定</span><br><span class="line">View &lt;=&gt; ViewModel &lt;=&gt; Model</span><br></pre></td></tr></table></figure><ol><li><p>MVVM是一种设计思想， 是 Model-View-ViewModel 的缩写。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。</p></li><li><p>在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到Model 中，而 Model 数据的变化也会立即反应到 View 上。</p></li><li><p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p></li></ol><h2 id="Vue-js-的优点"><a href="#Vue-js-的优点" class="headerlink" title="Vue.js 的优点"></a>Vue.js 的优点</h2><ol><li>低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</li><li>可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</li><li>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</li><li>可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写</li><li>易用灵活高效</li></ol><h2 id="Vue-组件是什么"><a href="#Vue-组件是什么" class="headerlink" title="Vue 组件是什么"></a>Vue 组件是什么</h2><p>组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以表现为用 is 特性进行了扩展的原生 HTML 元素。所有的 Vue 组件同时也都是 Vue 的实例，所以可接受相同的选项对象 (除了一些根级特有的选项) 并提供相同的生命周期钩子。</p><h1 id="Vue-cli"><a href="#Vue-cli" class="headerlink" title="Vue-cli"></a>Vue-cli</h1><p>Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，致力于将 Vue 生态中的工具基础标准化。</p><h2 id="Vue-脚手架-3-x-以上版本使用"><a href="#Vue-脚手架-3-x-以上版本使用" class="headerlink" title="Vue 脚手架 3.x 以上版本使用"></a>Vue 脚手架 3.x 以上版本使用</h2><p>全局安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add @vue/cli</span><br></pre></td></tr></table></figure></p><p>快速原型开发<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli-service-global</span><br></pre></td></tr></table></figure></p><p>创建项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vue create hello-world</span><br><span class="line">// 如果是在 Windows 上通过 minTTY 使用 Git Bash，交互提示符并不工作，需要执行下面命令</span><br><span class="line">winpty vue.cmd create hello-world</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd hello-world</span><br></pre></td></tr></table></figure><p>Project setup<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></table></figure></p><p>（以下命令 run 可以省略）<br>Compiles and hot-reloads for development<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run serve</span><br></pre></td></tr></table></figure></p><p>Compiles and minifies for production<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run build</span><br></pre></td></tr></table></figure></p><p>Run your tests<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run test</span><br></pre></td></tr></table></figure></p><p>Lints and fixes files<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run lint</span><br></pre></td></tr></table></figure></p><h2 id="Vuecli-3-x-版本-上图-与-2-x-初始化目录对比"><a href="#Vuecli-3-x-版本-上图-与-2-x-初始化目录对比" class="headerlink" title="Vuecli 3.x 版本(上图)与 2.x 初始化目录对比"></a>Vuecli 3.x 版本(上图)与 2.x 初始化目录对比</h2><p><img src="https://upload-images.jianshu.io/upload_images/7094266-35ec0c0fd8c70b11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-2e5b972e8f4586e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h1><p>Vue Router 是 Vue.js 官方的路由管理器。<br>安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router</span><br></pre></td></tr></table></figure></p><p>引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import VueRouter from &apos;vue-router&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure></p><p>配置路由文件，并在vue实例中注入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes:[&#123;</span><br><span class="line">    path:&apos;/user/:userId&apos;, // 指定要跳转的路径</span><br><span class="line">    name: &apos;user&apos;, // 命名路由，便于路由跳转</span><br><span class="line">    component: User// 指定要跳转的组件</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br><span class="line">const User = (&#123;</span><br><span class="line">  template: &apos;&lt;div&gt;User&lt;/div&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="确定视图加载的位置"><a href="#确定视图加载的位置" class="headerlink" title="确定视图加载的位置"></a>确定视图加载的位置</h2><p>视图可以添加命名，如果 router-view 没有设置名字，那么默认为 default<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;router-view name=&quot;a&quot;&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      components: &#123; // 同个路由，多个视图就需要多个组件,components 要有(s)</span><br><span class="line">        default: Foo,</span><br><span class="line">        a: Bar</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="实现路由跳转"><a href="#实现路由跳转" class="headerlink" title="实现路由跳转"></a>实现路由跳转</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/router-link&gt; // 路由导航到 /user/123</span><br></pre></td></tr></table></figure><p>等同于代码调用 router.push()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 编程式导航</span><br><span class="line">router.push(&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;) // 路由导航到 /user/123</span><br></pre></td></tr></table></figure></p><h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><p>使用动态路由参数，以冒号开头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: &apos;&lt;div&gt;User&lt;/div&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    // 动态路径参数 以冒号开头</span><br><span class="line">    &#123; path: &apos;/user/:id&apos;, component: User &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>现在呢，像 /user/foo 和 /user/bar 都将映射到相同的路由。</p><p>当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: &apos;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="响应路由参数变化"><a href="#响应路由参数变化" class="headerlink" title="响应路由参数变化"></a>响应路由参数变化</h2><p>动态路由会引起组件复用，如果想对路由参数的变化作出响应，可以简单地 <strong>watch</strong> (监测变化) $route 对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: &apos;...&apos;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    &apos;$route&apos; (to, from) &#123;</span><br><span class="line">      // 对路由变化作出响应...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者使用 <strong>beforeRouteUpdate</strong> 导航守卫</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: &apos;...&apos;,</span><br><span class="line">  beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">    // react to route changes...</span><br><span class="line">    // don&apos;t forget to call next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由组件参数解耦"><a href="#路由组件参数解耦" class="headerlink" title="路由组件参数解耦"></a>路由组件参数解耦</h2><p>在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。可使用 props 解耦组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  props: [&apos;id&apos;],</span><br><span class="line">  template: &apos;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &apos;/user/:id&apos;, component: User, props: true &#125;,</span><br><span class="line"></span><br><span class="line">    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/user/:id&apos;,</span><br><span class="line">      components: &#123; default: User, sidebar: Sidebar &#125;,</span><br><span class="line">      props: &#123; default: true, sidebar: false &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>props 有三种模式：布尔模式、对象模式、函数模式</p><h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><p>Vuex 是一个为 Vue.js 开发的状态管理模式：采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><h2 id="在-store-存储-内有下列核心概念"><a href="#在-store-存储-内有下列核心概念" class="headerlink" title="在 store (存储)内有下列核心概念"></a>在 store (存储)内有下列核心概念</h2><p><strong>State()：核心原始数据</strong> 展示<br><strong>Getter：计算属性，根据所依赖的数据的变化计算自身变化</strong> 存储<br><strong>Mutation(转变)：提交 mutation 才能改变存储状态</strong><br><strong>Action：</strong>Action 类似于 mutation，不同在于：<br>Action 提交的是 mutation，而不是直接变更状态。<br>Action 可以包含任意异步操作。<br><strong>Module：可以将将 store 分割</strong><br>一般放在 state 文件夹下</p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-c1e2d56805eff7e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="vuex状态管理的流程"><a href="#vuex状态管理的流程" class="headerlink" title="vuex状态管理的流程"></a>vuex状态管理的流程</h2><p>view =&gt; actions =&gt; mutations =&gt; state =&gt; view</p><h2 id="核心概念详解"><a href="#核心概念详解" class="headerlink" title="核心概念详解"></a>核心概念详解</h2><h3 id="state：记录所有公共数据状态的对象"><a href="#state：记录所有公共数据状态的对象" class="headerlink" title="state：记录所有公共数据状态的对象"></a>state：记录所有公共数据状态的对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 组件如何获取</span><br><span class="line">this.$store.state.XXX</span><br><span class="line">// 此处的 XXX 是 state 内定义的数据状态的键名</span><br></pre></td></tr></table></figure><h3 id="mutations：包含所有-操作数据状态的方法-的对象"><a href="#mutations：包含所有-操作数据状态的方法-的对象" class="headerlink" title="mutations：包含所有 操作数据状态的方法 的对象"></a>mutations：包含所有 操作数据状态的方法 的对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 组件如何调用</span><br><span class="line">this.$store.commit(XXX)</span><br><span class="line">// 此处的 XXX是 mutations 中定义的方法名</span><br></pre></td></tr></table></figure><h3 id="actions：用于操作-mutations-内方法-的对象"><a href="#actions：用于操作-mutations-内方法-的对象" class="headerlink" title="actions：用于操作 mutations 内方法 的对象"></a>actions：用于操作 mutations 内方法 的对象</h3><p>actions 提交的是 mutation，而不是直接变更状态 actions可以包含异步操作，但是 mutation 只能包含同步操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 如何调用</span><br><span class="line">this.$store.dispatch(XXX)</span><br><span class="line">// 此处的XXX是你在actions中定义的方法名</span><br></pre></td></tr></table></figure></p><h3 id="getters：定义状态内容的方法-的对象"><a href="#getters：定义状态内容的方法-的对象" class="headerlink" title="getters：定义状态内容的方法 的对象"></a>getters：定义状态内容的方法 的对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.$store.getters.XXX</span><br><span class="line">// 此处的XXX是你在getters里定义的方法名</span><br></pre></td></tr></table></figure><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>当应用较大时，store将变得臃肿，Vuex 允许我们将 store 分割成模块（module）。<br>每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a // -&gt; moduleA 的状态</span><br><span class="line">store.state.b // -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure></p><h1 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h1><p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征：</p><ul><li>从浏览器中创建 XMLHttpRequest</li><li>从 node.js 发出 http 请求</li><li>支持 Promise API拦截</li><li>请求和响应转换</li><li>请求和响应数据取消</li><li>请求自动转换JSON数据</li><li>客户端支持防止 CSRF/XSRF</li></ul><ol><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure></li><li><p>引入加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;</span><br></pre></td></tr></table></figure></li><li><p>将axios全局挂载到 Vue 原型上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$http = axios</span><br></pre></td></tr></table></figure></li></ol><h2 id="设置全局-axios-默认值"><a href="#设置全局-axios-默认值" class="headerlink" title="设置全局 axios 默认值"></a>设置全局 axios 默认值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 设置基础路径，一般为后端接口线上地址根路径</span><br><span class="line">axios.defaults.baseURL = &apos;https://api.example.com&apos;;</span><br><span class="line">// 设置默认 token</span><br><span class="line">axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;</span><br><span class="line">// 默认 POST 请求</span><br><span class="line">axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;;</span><br></pre></td></tr></table></figure><h2 id="axios-的-url-有两种传递参数的形式"><a href="#axios-的-url-有两种传递参数的形式" class="headerlink" title="axios 的 url 有两种传递参数的形式"></a>axios 的 url 有两种传递参数的形式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 第一种 对象形式</span><br><span class="line">this.$http.get(&apos;/user&apos;, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: 12345</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">// 如果只有一个参数，可以省略 params</span><br><span class="line">this.$http.get(&apos;/user&apos;, &#123;</span><br><span class="line">      ID: 12345</span><br><span class="line">  &#125;) </span><br><span class="line">--------------------------------- </span><br><span class="line">// 第二种 形式</span><br><span class="line">this.$http.get(&apos;https://cnodejs.org/api/v1/topics?page=1&amp;limit=15&apos;)</span><br></pre></td></tr></table></figure><h2 id="POST-传递数据有两种格式："><a href="#POST-传递数据有两种格式：" class="headerlink" title="POST 传递数据有两种格式："></a>POST 传递数据有两种格式：</h2><ol><li>form­-data ?page=1&amp;limit=48</li><li>x-­www­-form-­urlencoded { page: 1,limit: 10 }</li></ol><p><strong>在 axios 中，post 请求接收的参数必须是 form­-data 形式<br>如果要使用 x-­www­-form-­urlencoded 形式，需要用 qs 插件—qs.stringify 转换</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.$http.post(&apos;/user&apos;, qs.stringify(&#123;</span><br><span class="line">   ID: 12345</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h2 id="实现增删改查"><a href="#实现增删改查" class="headerlink" title="实现增删改查"></a>实现增删改查</h2><h3 id="发起-GET-请求：查"><a href="#发起-GET-请求：查" class="headerlink" title="发起 GET 请求：查"></a>发起 GET 请求：查</h3><p><img src="https://upload-images.jianshu.io/upload_images/7094266-12145e74b1272089.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const axios = require(&apos;axios&apos;) // 下同省略</span><br><span class="line"></span><br><span class="line">//发起一个user请求，参数为给定的ID</span><br><span class="line">axios.get(&apos;/user?ID=12345&apos;)</span><br><span class="line">  .then((response) =&gt; &#123;</span><br><span class="line">    console.log(response)</span><br><span class="line">  &#125;</span><br><span class="line">  .catch((error) =&gt; &#123;</span><br><span class="line">    console.log(error)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="发起-POST-请求：增"><a href="#发起-POST-请求：增" class="headerlink" title="发起 POST 请求：增"></a>发起 POST 请求：增</h3><p><img src="https://upload-images.jianshu.io/upload_images/7094266-8609f819ec24a9ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.post(&apos;/user&apos;, &#123;</span><br><span class="line">  firstName: &apos;yuanda&apos;,</span><br><span class="line">  lastName: &apos;zhou&apos;</span><br><span class="line">&#125;)</span><br><span class="line">  .then((response) =&gt; &#123;</span><br><span class="line">    console.log(response)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function(error)&#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.request(config)</span><br><span class="line">axios.get(url[,config])</span><br><span class="line">axios.delete(url[,config]) // 删除</span><br><span class="line">axios.head(url[,config])</span><br><span class="line">axios.options(url[,config])</span><br><span class="line">axios.post(url[,data[,config]])</span><br><span class="line">axios.put(url[,data[,config]]) // 改</span><br><span class="line">axios.patch(url[,data[,config]])</span><br></pre></td></tr></table></figure><p>PUT 和 POST 方法的区别是,PUT方法是幂等的：连续调用一次或者多次的效果相同（无副作用）。连续调用同一个POST可能会带来额外的影响，比如多次提交订单。</p><h2 id="并发请求"><a href="#并发请求" class="headerlink" title="并发请求"></a>并发请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getUserAccount()&#123;</span><br><span class="line">    return axios.get(&apos;/user/12345&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getUserPermissions()&#123;</span><br><span class="line">    return axios.get(&apos;/user/12345/permissions&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.all([getUerAccount(),getUserPermissions()])</span><br><span class="line">    .then(axios.spread(function(acc,pers)&#123;</span><br><span class="line">        //两个请求现在都完成</span><br><span class="line">    &#125;));</span><br></pre></td></tr></table></figure><p>axios.all 使用的是类似 Primise.all 的功能，所以如果其中有一个请求出现了错误那么就会停止请求，所以建议对于单个请求最好附加上处理的 catch。</p><h2 id="拦截器-interceptors"><a href="#拦截器-interceptors" class="headerlink" title="拦截器 interceptors"></a>拦截器 interceptors</h2><p>你可以在<strong>请求</strong>或者<strong>响应</strong>被 then 或者 catch 处理之前对他们进行拦截。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//添加一个请求拦截器</span><br><span class="line">axios.interceptors.request.use(function(config)&#123;</span><br><span class="line">    //在请求发送之前做一些事</span><br><span class="line">    return config;</span><br><span class="line">&#125;,function(error)&#123;</span><br><span class="line">    //当出现请求错误是做一些事</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//添加一个返回拦截器</span><br><span class="line">axios.interceptors.response.use(function(response)&#123;</span><br><span class="line">    //对返回的数据进行一些处理</span><br><span class="line">    return response;</span><br><span class="line">&#125;,function(error)&#123;</span><br><span class="line">    //对返回的错误进行一些处理</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>用 eject 移除拦截器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myInterceptor = axios.interceptors.request.use(function()&#123;/*...*/&#125;);</span><br><span class="line">axios.interceptors.request.eject(myInterceptor);</span><br></pre></td></tr></table></figure></p><h2 id="axios-如何获取-cookie"><a href="#axios-如何获取-cookie" class="headerlink" title="axios 如何获取 cookie"></a>axios 如何获取 cookie</h2><p>axios 默认是不让 ajax 请求头部携带cookie的，因此，在 main.js 中设置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">axios.defaults.withCredentials=true; //让ajax携带cookie</span><br><span class="line">Vue.prototype.$axios = axios;</span><br></pre></td></tr></table></figure></p><p>通过js原生接口来获取:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let allCookies = document.cookie</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>http://adashuai5.com/2019/02/26/Vue-%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/#disqus_thread</comments>
    </item>
    
    <item>
      <title>hash 模式和 history 模式小记</title>
      <link>http://adashuai5.com/2019/01/28/hash-%E6%A8%A1%E5%BC%8F%E5%92%8C-history-%E6%A8%A1%E5%BC%8F%E5%B0%8F%E8%AE%B0/</link>
      <guid>http://adashuai5.com/2019/01/28/hash-%E6%A8%A1%E5%BC%8F%E5%92%8C-history-%E6%A8%A1%E5%BC%8F%E5%B0%8F%E8%AE%B0/</guid>
      <pubDate>Mon, 28 Jan 2019 13:55:33 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;前端路由&quot;&gt;&lt;a href=&quot;#前端路由&quot; class=&quot;headerlink&quot; title=&quot;前端路由&quot;&gt;&lt;/a&gt;前端路由&lt;/h1&gt;&lt;p&gt;随着 ajax 的流行，异步数据请求交互运行在不刷新浏览器的情况下进行。而异步交互体验的更高级版本就是 SPA —— 单页应
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h1><p>随着 ajax 的流行，异步数据请求交互运行在不刷新浏览器的情况下进行。而异步交互体验的更高级版本就是 SPA —— 单页应用。单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。</p><h2 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h2><p>类似于服务端路由，前端路由实现起来其实也很简单，就是匹配不同的 url 路径，进行解析，然后动态的渲染出区域 html 内容。但是这样存在一个问题，就是 url 每次变化的时候，都会造成页面的刷新。那解决问题的思路便是在改变 url 的情况下，保证页面的不刷新。在 2014 年之前，大家是通过 hash 来实现路由，url hash 就是类似于：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.xxx.com/#/login</span><br></pre></td></tr></table></figure></p><p>这种 #。后面 hash 值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面。另外每次 hash 值的变化，还会触发hashchange 这个事件，通过这个事件我们就可以知道 hash 值发生了哪些变化。然后我们便可以监听hashchange来实现更新页面部分内容的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function matchAndUpdate () &#123;</span><br><span class="line">   // todo 匹配 hash 做 dom 更新操作</span><br><span class="line">&#125;</span><br><span class="line">window.addEventListener(&apos;hashchange&apos;, matchAndUpdate)</span><br></pre></td></tr></table></figure></p><h2 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h2><p>14年后，因为 HTML5 标准发布。多了两个 API，pushState 和 replaceState，通过这两个 API 可以改变 url 地址且不会发送请求。同时还有 popstate 事件。通过这些就能用另一种方式来实现前端路由了，但原理都是跟 hash 实现相同的。用了 HTML5 的实现，单页路由的 url 就不会多出一个 #，变得更加美观。但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function matchAndUpdate () &#123;</span><br><span class="line">   // todo 匹配路径 做 dom 更新操作</span><br><span class="line">&#125;</span><br><span class="line">window.addEventListener(&apos;popstate&apos;, matchAndUpdate)</span><br></pre></td></tr></table></figure></p><p>(以上内容转载自<a href="https://zhuanlan.zhihu.com/p/37730038" target="_blank" rel="noopener">前端路由简介以及vue-router实现原理</a>部分内容，作者总结得很好)</p><p>在 vue-router 中，默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。<br>如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面</p><h2 id="hash-模式和-history-模式主要区别"><a href="#hash-模式和-history-模式主要区别" class="headerlink" title="hash 模式和 history 模式主要区别"></a>hash 模式和 history 模式主要区别</h2><ol><li>使用 hash 模式，当 一个窗口的 hash （URL 中 # 后面的部分）改变时就会触发 hashchange 事件，而不会刷新页面，比如: 在页面内点击带有锚点的 a 标签，不会刷新页面。</li><li>使用 history，URL 没有了 #，一般都需要服务器端配置或支持 SSR，否则刷新页面服务器会返回 404。</li></ol><h2 id="hash-模式以及为什么改变-hash-不刷新页面——URL的井号‘-’"><a href="#hash-模式以及为什么改变-hash-不刷新页面——URL的井号‘-’" class="headerlink" title="hash 模式以及为什么改变 hash 不刷新页面——URL的井号‘#’"></a>hash 模式以及为什么改变 hash 不刷新页面——<a href="http://www.ruanyifeng.com/blog/2011/03/url_hash.html" target="_blank" rel="noopener">URL的井号‘#’</a></h2><h2 id="有关-history-对象"><a href="#有关-history-对象" class="headerlink" title="有关 history 对象"></a>有关 <a href="https://javascript.ruanyifeng.com/bom/history.html#toc1" target="_blank" rel="noopener">history 对象</a></h2><p>由于 HTML5 只在 IE9 以上支持</p><h2 id="控制-vue-router-内的自动降级"><a href="#控制-vue-router-内的自动降级" class="headerlink" title="控制 vue-router 内的自动降级"></a>控制 vue-router 内的自动降级</h2><blockquote><p>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</p></blockquote><p>可使用 <strong>fallback</strong> API</p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-b7d0691f21ffc7cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content:encoded>
      
      <comments>http://adashuai5.com/2019/01/28/hash-%E6%A8%A1%E5%BC%8F%E5%92%8C-history-%E6%A8%A1%E5%BC%8F%E5%B0%8F%E8%AE%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>从「从输入URL到页面加载」谈及Web性能优化</title>
      <link>http://adashuai5.com/2018/12/29/%E4%BB%8E%E3%80%8C%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E3%80%8D%E8%B0%88%E5%8F%8AWeb%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
      <guid>http://adashuai5.com/2018/12/29/%E4%BB%8E%E3%80%8C%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E3%80%8D%E8%B0%88%E5%8F%8AWeb%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
      <pubDate>Sat, 29 Dec 2018 06:09:32 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;如何理解-Web-性能优化&quot;&gt;&lt;a href=&quot;#如何理解-Web-性能优化&quot; class=&quot;headerlink&quot; title=&quot;如何理解 Web 性能优化&quot;&gt;&lt;/a&gt;如何理解 Web 性能优化&lt;/h1&gt;&lt;p&gt;事实上就是用户觉得页面加载很快，用户从输入URL（网
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="如何理解-Web-性能优化"><a href="#如何理解-Web-性能优化" class="headerlink" title="如何理解 Web 性能优化"></a>如何理解 Web 性能优化</h1><p>事实上就是用户觉得页面加载很快，用户从输入URL（网址）到页面在浏览器上加载出来的时间很短；与之相对的有如服务器性能优化（如网页占的 CPU 少），一定要区分开来。<br>对于用户众多的网站，节约下的加载时间或能带来可观的收入，这便是前端 Web 性能优化的意义。</p><h1 id="从输入-URL-到页面加载发生了什么"><a href="#从输入-URL-到页面加载发生了什么" class="headerlink" title="从输入 URL 到页面加载发生了什么"></a>从输入 URL 到页面加载发生了什么</h1><p>一道所有前端耳熟能详的经典面试题，也确实是需要前端去深入研究的东西。下面我会简单介绍其过程，并罗列相关的 Web 优化方案。</p><h2 id="0-缓存"><a href="#0-缓存" class="headerlink" title="0. 缓存"></a>0. 缓存</h2><p>当我们在浏览器上输入网址，浏览器首先会查看是否有缓存，如果之前已经访问过该网站，则会有缓存，那浏览器就不必再向服务器发请求了，用户则能够很快得看到内容。Web 性能优化有极大一部分都是优化缓存，缓存事实上又分为数据库缓存、代理服务器缓存、还有我们熟悉的 CDN 缓存，以及浏览器缓存等，部分内容后文介绍。</p><h2 id="1-DNS-查询"><a href="#1-DNS-查询" class="headerlink" title="1. DNS 查询"></a>1. DNS 查询</h2><p>DNS 查询就像电话簿，你在浏览器地址栏输入网址，通过 DNS 查询得到域名的真实 IP。</p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-d21c9b5e4b39ad6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>DNS查询完成之前，浏览器无法从服务器下载任何数据。</p><h3 id="优化方案：减少-DNS-查询"><a href="#优化方案：减少-DNS-查询" class="headerlink" title="优化方案：减少 DNS 查询"></a>优化方案：减少 DNS 查询</h3><h4 id="1-1-DNS-缓存"><a href="#1-1-DNS-缓存" class="headerlink" title="1.1 DNS 缓存"></a>1.1 DNS 缓存</h4><p>ISP、局域网、操作系统、浏览器等都会有相应的DNS缓存机制。</p><h4 id="1-2-减少页面的唯一域名"><a href="#1-2-减少页面的唯一域名" class="headerlink" title="1.2 减少页面的唯一域名"></a>1.2 减少页面的唯一域名</h4><p>因为每次 DNS 查询就是查找唯一域名的过程，那么域名越少，DNS 查询就越少，应该尽量将资源放在同一域名。当然这样做又有其他问题，下文详解。</p><h2 id="2-TCP-连接"><a href="#2-TCP-连接" class="headerlink" title="2. TCP 连接"></a>2. TCP 连接</h2><p>经典的三次握手和四次挥手，不展开赘述。<br>简单讲讲优化方案：TCP 连接复用（TCP Connection Reuse），在 HTTP 请求头中的 Connection 上加 keep-alive；HTTP/2.0 多路复用等。</p><h2 id="3-HTTP-请求及响应"><a href="#3-HTTP-请求及响应" class="headerlink" title="3. HTTP 请求及响应"></a>3. HTTP 请求及响应</h2><p>直接讲优化策略</p><h4 id="3-1-避免不必要的重定向"><a href="#3-1-避免不必要的重定向" class="headerlink" title="3.1 避免不必要的重定向"></a>3.1 避免不必要的重定向</h4><blockquote><p>最浪费的重定向经常发生、而且很容易被忽略：URL 末尾应该添加/但未添加。比如，访问<a href="http://astrology.yahoo.com/astrology将被301重定向到" target="_blank" rel="noopener">http://astrology.yahoo.com/astrology将被301重定向到</a> <a href="http://astrology.yahoo.com/astrology/（注意末尾的" target="_blank" rel="noopener">http://astrology.yahoo.com/astrology/（注意末尾的</a> /）。如果使用 Apache，可以通过Alias或mod_rewrite或DirectorySlash解决这个问题。</p></blockquote><h4 id="3-2-Cookie"><a href="#3-2-Cookie" class="headerlink" title="3.2 Cookie"></a>3.2 Cookie</h4><h5 id="3-2-1减少-Cookie-大小"><a href="#3-2-1减少-Cookie-大小" class="headerlink" title="3.2.1减少 Cookie 大小"></a>3.2.1减少 Cookie 大小</h5><p>每次请求都会带上对应的 Cookie，减少 Cookie 大小可以降低其对响应速度的影响：</p><ul><li>去除不必要的 Cookie；</li><li>尽量压缩 Cookie 大小；</li><li>注意设置 Cookie 的 domain 级别，如无必要，不要影响到 sub-domain；</li><li>设置合适的过期时间。</li></ul><h5 id="3-2-2-静态资源使用无-Cookie-域名"><a href="#3-2-2-静态资源使用无-Cookie-域名" class="headerlink" title="3.2.2 静态资源使用无 Cookie 域名"></a>3.2.2 静态资源使用无 Cookie 域名</h5><p>静态资源一般无需使用 Cookie，可以把它们放在使用二级域名或者专门域名的无 Cookie 服务器上，降低 Cookie 传送的造成的流量浪费，提高响应速度。</p><h4 id="3-3-添加-Expires-或-Cache-Control-响应头"><a href="#3-3-添加-Expires-或-Cache-Control-响应头" class="headerlink" title="3.3 添加 Expires 或 Cache-Control 响应头"></a>3.3 添加 Expires 或 Cache-Control 响应头</h4><p>HTTP/1.1 增加的 Cache-Control，它比 Expires 等好在其设定时间是相对的，避免了用户本地设置时间落后所造成的无法良好缓存的问题等。</p><ul><li>静态内容：将 Expires 响应头设置为将来很远的时间，实现「永不过期」策略；</li><li>动态内容：设置合适的 Cache-Control 响应头，让浏览器有条件地发起请求。</li></ul><h4 id="3-4-配置-Etag"><a href="#3-4-配置-Etag" class="headerlink" title="3.4 配置 Etag"></a>3.4 配置 Etag</h4><p>通过如 MD5 等加密算法，设置缓存体的 Etag 配合 3.3 的缓存时间使用，这样 Cache-Control 就可以设置较长时间（max-age 设置个十年半载 ），只要浏览器缓存中资源与源服务器中的资源 Etag 不一致，说明内容更新了，此时再下载新资源；Etag 匹配成功则直接响应 304，不用重复下载了用户自然感觉很快。</p><h4 id="3-5-使用-Gzip"><a href="#3-5-使用-Gzip" class="headerlink" title="3.5 使用 Gzip"></a>3.5 使用 Gzip</h4><p>使用 Gzip 就是将 HTML、CSS、JS、XML、JSON 等资源进行 Gzip 高效压缩，减少资源体积那么下载就会更快。<br>Gzip 压缩通常可以减少 70% 的响应大小，对某些文件更可能高达 90%，比 Deflate 更高效。主流 Web 服务器都有相应模块，而且绝大多数浏览器支持 Gzip 解码。<br>从HTTP/1.1开始，客户端就有了支持压缩的 Accept-Encoding HTTP 请求头。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure></p><p>服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web服务器通过 Content-Encoding 响应头来通知客户端。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure></p><p>需要注意的是，已经压缩过的内容如图片和PDF不要使用 Gzip，另外还有文件内容本身就很小，这些资源再使用 Gzip 反而会增加资源下载时间，浪费 CPU 资源，而且还可能增加文件体积。</p><h3 id="值得一提"><a href="#值得一提" class="headerlink" title="值得一提"></a>值得一提</h3><p>HTTP 请求的另一个优化方案是增加同时请求的数量，浏览器会同时发送多个请求，但是同一域名最多同时发送 4~8 个（不同浏览器不同）请求，那么当资源过多时，可以采用增加域名的方法增加并发量。当然这一方法又与上述 DNS 查询的优化方案矛盾，真正使用的时候就需要权衡。<br>另外，既然一次只能发的请求有限，就应该将重要的需要优先展示的资源先请求：</p><h4 id="3-6-延迟加载（懒加载）"><a href="#3-6-延迟加载（懒加载）" class="headerlink" title="3.6 延迟加载（懒加载）"></a>3.6 延迟加载（懒加载）</h4><p>页面初始加载时哪些内容是绝对必需的？不在答案之列的资源都可以延迟加载。比如：</p><ul><li>非首屏使用的数据、样式、脚本、图片等；</li><li>用户交互时才会显示的内容。</li></ul><p>遵循「渐进增强」理念开发的网站：JavaScript用于增强用用户体验，但没有（不支持） JavaScript也能正常工作，完全可以延迟加载JavaScript。</p><blockquote><p>将首屏以外的HTML放在不渲染的元素中，如隐藏的&lt;textarea&gt;，或者type属性为非执行脚本的 &lt;script&gt; 标签中，减少初始渲染的DOM元素数量，提高速度。等首屏加载完成或者用户操作时，再去渲染剩余的页面内容。</p></blockquote><h4 id="3-7-预加载"><a href="#3-7-预加载" class="headerlink" title="3.7 预加载"></a>3.7 预加载</h4><p>预先加载利用浏览器空闲时间请求将来要使用的资源，以便用户访问下一页面时更快地响应。</p><h2 id="4-浏览器解析渲染页面"><a href="#4-浏览器解析渲染页面" class="headerlink" title="4. 浏览器解析渲染页面"></a>4. 浏览器解析渲染页面</h2><p>响应完成后，浏览器下载完资源，就开始解析资源生成页面了。对于前端来说，这部分内容是完全需要我们去掌控的，我们也来简单介绍一下对应的优化内容，部分内容如懒加载等上面已经提及就不再重复。</p><h4 id="4-1-写对文档类型声明-lt-DOCTYPE-html-gt"><a href="#4-1-写对文档类型声明-lt-DOCTYPE-html-gt" class="headerlink" title="4.1 写对文档类型声明 &lt;!DOCTYPE html&gt;"></a>4.1 写对文档类型声明 &lt;!DOCTYPE html&gt;</h4><blockquote><p>这个声明的目的是防止浏览器在渲染文档时，切换到我们称为“<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Quirks_Mode_and_Standards_Mode" target="_blank" rel="noopener">怪异模式(兼容模式)</a>”的渲染模式。“<code>&amp;lt;!DOCTYPE html&amp;gt;</code>“ 确保浏览器按照最佳的相关规范进行渲染，而不是使用一个不符合规范的渲染模式。</p></blockquote><p>不写或写错文档类型声明，会浪费浏览器渲染页面的时间或引起错误排版。</p><h4 id="4-2-CSS-放在-lt-head-gt-中"><a href="#4-2-CSS-放在-lt-head-gt-中" class="headerlink" title="4.2 CSS 放在 &lt;head&gt; 中"></a>4.2 CSS 放在 &lt;head&gt; 中</h4><p>把样式表放在 &lt;head&gt; 中可以让页面渐进渲染，尽早呈现视觉反馈，给用户加载速度很快的感觉。<br>这对内容比较多的页面尤为重要，用户可以先查看已经下载渲染的内容，而不是盯着白屏等待。<br>如果把样式表放在页面底部，一些浏览器为减少重绘，会在 CSS 加载完成以后才渲染页面，用户只能对着白屏干瞪眼，用户体验极差。把样式表放到文档的HEAD部分能让页面看起来加载地更快。</p><h4 id="4-2-把脚本放在页面底部"><a href="#4-2-把脚本放在页面底部" class="headerlink" title="4.2 把脚本放在页面底部"></a>4.2 把脚本放在页面底部</h4><p>浏览器下载脚本时，会阻塞其他资源并行下载，即使是来自不同域名的资源，并且，没有 js 并不邮箱呈现在用户目前的内容的观感。因此，最好将脚本放在底部，以提高页面加载速度。<br>一些特殊场景无法将脚本放到页面底部的，可以考虑&lt;script&gt;的以下属性：</p><ul><li>defer 属性；</li><li>HTML5 新增的async属性。</li></ul><h4 id="4-3-使用外部-JavaScript-和-CSS"><a href="#4-3-使用外部-JavaScript-和-CSS" class="headerlink" title="4.3 使用外部 JavaScript 和 CSS"></a>4.3 使用外部 JavaScript 和 CSS</h4><p>外部 JavaScript 和 CSS 文件可以被浏览器缓存，在不同页面间重用，也能降低页面大小。<br>当然，实际中也需要考虑代码的重用程度。如果仅仅是某个页面使用到的代码，可以考虑内嵌在页面中，减少HTTP请求数。另外，可以在首页加载完成以后，预先加载子页面的资源。</p><h4 id="4-4-合并和压缩-JS-CSS-等文件"><a href="#4-4-合并和压缩-JS-CSS-等文件" class="headerlink" title="4.4 合并和压缩 JS/CSS 等文件"></a>4.4 合并和压缩 JS/CSS 等文件</h4><p>通过该方法减少页面所需资源，减少请求数量，加快响应时间。现在 webpack 打包工具都已经默认实现了。</p><h4 id="4-5-减少-DOM-操作和使用高效的事件处理"><a href="#4-5-减少-DOM-操作和使用高效的事件处理" class="headerlink" title="4.5 减少 DOM 操作和使用高效的事件处理"></a>4.5 减少 DOM 操作和使用高效的事件处理</h4><ul><li>缓存已经访问过的元素；</li><li>使用 DocumentFragment 暂存 DOM，整理好以后再插入 DOM 树；</li><li>操作 className，而不是多次读写 style；</li><li>避免使用 JavaScript 修复布局；</li><li>减少绑定事件监听的节点，如通过事件委托（当然现在浏览器功能强大，影响不大）；</li><li>尽早处理事件，在 DOMContentLoaded 即可进行，不用等到 load 以后。</li></ul><h4 id="4-6-图片优化"><a href="#4-6-图片优化" class="headerlink" title="4.6 图片优化"></a>4.6 图片优化</h4><p>如何将图片变得又小又好看是一个工程师实力的体现，这里不过多赘述，大家可以查看我后文提供的资源。</p><h4 id="4-7-使用-CND"><a href="#4-7-使用-CND" class="headerlink" title="4.7 使用 CND"></a>4.7 使用 CND</h4><blockquote><p>内容分发网络（Content delivery network 或 Content distribution network）是指一种透过互联网互相连接的计算机网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。</p></blockquote><p>动态 CDN，使用离你最近的服务器；CDN 没有 Cookie，使用 CDN 可以减少 Cookie；CND 会自动合并脚本文件等，减少请求数量；当然，使用 CND 同时也增加了一个域名，增大了同时请求数量。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://upload-images.jianshu.io/upload_images/7094266-2696c8f1d212f5d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>该文大量参考了雅虎 35 军规，增加了一些自己的理解并舍弃了一些已经过时的内容。细节内容比较少，主要是笼统地将 Web 性能优化的思路做了梳理，很多内容都值得我们去深入研究。当然其中部分内容顺序还是不佳，因为很多内容事实上是贯穿在整个过程当中的，正如 Web 性能优化是个整体，需要权衡所有冲突。希望本文可以给你一些在面试官问道你时的思路。<br>深入阅读 <a href="https://zhuanlan.zhihu.com/p/34453198" target="_blank" rel="noopener">从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！</a></p><p>本文参考：<br><a href="https://juejin.im/post/5b73ef38f265da281e048e51" target="_blank" rel="noopener">前端性能优化之雅虎35条军规</a><br><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">前端经典面试题: 从输入URL到页面加载发生了什么？</a><br>MDN<br>维基百科</p>]]></content:encoded>
      
      <comments>http://adashuai5.com/2018/12/29/%E4%BB%8E%E3%80%8C%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E3%80%8D%E8%B0%88%E5%8F%8AWeb%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/#disqus_thread</comments>
    </item>
    
    <item>
      <title>优先级 和 CSS 预处理</title>
      <link>http://adashuai5.com/2018/12/20/%E4%BC%98%E5%85%88%E7%BA%A7-%E5%92%8C-CSS-%E9%A2%84%E5%A4%84%E7%90%86/</link>
      <guid>http://adashuai5.com/2018/12/20/%E4%BC%98%E5%85%88%E7%BA%A7-%E5%92%8C-CSS-%E9%A2%84%E5%A4%84%E7%90%86/</guid>
      <pubDate>Thu, 20 Dec 2018 14:30:16 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;前言扯淡&quot;&gt;&lt;a href=&quot;#前言扯淡&quot; class=&quot;headerlink&quot; title=&quot;前言扯淡&quot;&gt;&lt;/a&gt;前言扯淡&lt;/h2&gt;&lt;p&gt;前两天电话面试，被问道了一些 CSS 的基础问题，虽然答上来了，但是不够全面，而且给自己最大的感受是自己对一些概念十分模棱两
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前言扯淡"><a href="#前言扯淡" class="headerlink" title="前言扯淡"></a>前言扯淡</h2><p>前两天电话面试，被问道了一些 CSS 的基础问题，虽然答上来了，但是不够全面，而且给自己最大的感受是自己对一些概念十分模棱两可，最直观的体现是有时候知道这个概念，却不知道他叫什么。自以为懂，最为致命。<br>需求是最好的学习API的方式，面试找工作是最好的学习沉淀的过程。快俩个月没写博客了，终于今天在回顾时有一点点小的感悟，打算记录下来，主要是给自己看。废话不多说，开始正文。</p><h2 id="首先是-优先级"><a href="#首先是-优先级" class="headerlink" title="首先是 优先级"></a>首先是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity" target="_blank" rel="noopener">优先级</a></h2><p>链接是文档，优先级主要是指CSS属性的优先级。</p><blockquote><p>浏览器通过优先级来判断哪一些属性值与一个元素最为相关，从而在该元素上应用这些属性值。优先级是基于不同种类选择器组成的匹配规则。</p></blockquote><p>简单来说，当你给一个元素声明（或该元素继承而来）多个相同属性时（前提），浏览器选择哪一个作为该元素的应用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1 id=&quot;title&quot; class=&quot;title&quot; style=&quot;color: yellow;&quot;&gt;优先级&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!--优先级显示为 pink--&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1&#123;</span><br><span class="line">  color: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.title&#123;</span><br><span class="line">  color: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#title&#123;</span><br><span class="line">  color: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1&#123;</span><br><span class="line">  color: pink !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优先级如何确定："><a href="#优先级如何确定：" class="headerlink" title="优先级如何确定："></a>优先级如何确定：</h4><p>选择器优先级，下面三种优先级递增：（不细看文档都不知道这些平时在用的选择器的所有名称）</p><ol><li><strong>ID选择器</strong>（例如, #title）</li><li><strong>类选择器</strong>（class selectors） (例如,.title)，<strong>属性选择器</strong>（attributes selectors）（例如, [type=”radio”]），<strong>伪类</strong>（pseudo-classes）（例如, :hover）</li><li><strong>类型选择器</strong>（type selectors）（例如, h1）和 <strong>伪元素</strong>（pseudo-elements）（例如, ::before）</li></ol><p><strong>通配选择符</strong>（universal selector）(*), <strong>关系选择符</strong>（combinators） (+, &gt;, ~, ‘ ‘)  和 <strong>否定伪类</strong>（negation pseudo-class）(:not()) 对优先级没有影响。（但是，在 :not() 内部声明的选择器是会影响优先级）。<br>给元素添加的<strong>内联样式</strong>  (例如, style=”color: yellow;”) 总会覆盖外部样式表的任何样式 ，因此可看作是具有最高的优先级。<br><strong>!important</strong> 是例外，此声明将覆盖任何其他声明，技术上!important与优先级无关，但它与它直接相关。</p><h4 id="如何利用优先级"><a href="#如何利用优先级" class="headerlink" title="如何利用优先级"></a>如何利用优先级</h4><ol><li>选择器越具体，优先级越高。</li><li>相同优先级情况下，后面的样式覆盖前面的。</li><li>!important 最特殊，有他的声明最优先，但应该避免使用。</li></ol><p>上面内容均来自 MDN，也就是我给的链接，还有很多如<code>无视DOM树中的距离</code>等没有记录。大家还是直接看MDN为宜。这些真的是简单的基础内容，但确实有很多细节，如果能够因为无意看到我的文章去看MDN文档而收获一些东西，便是此文的意义了。<br>扩展阅读 <a href="https://github.com/jincdream/jincdream.github.io/issues/14" target="_blank" rel="noopener">真正理解”CSS选择器的优先级”</a></p><h2 id="CSS预处理（预编译）"><a href="#CSS预处理（预编译）" class="headerlink" title="CSS预处理（预编译）"></a>CSS预处理（预编译）</h2><p>当面试关问我知不知道CSS预处理的时候，我一时并没有将其与平常再用的 LESS、SCSS 等预编译器对上。也就是我文章开头提到的，有时我们以为熟知的东西，事实上我们那么陌生。</p><hr><p>(以下内容来自 <a href="http://efe.baidu.com/blog/revisiting-css-preprocessors/" target="_blank" rel="noopener">再谈 CSS 预处理器</a>)<br>CSS 预处理器是什么？一般来说，它们基于 CSS 扩展了一套属于自己的 DSL，来解决我们书写 CSS 时难以解决的问题：</p><ul><li>语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器；</li><li>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。</li></ul><p>所以这就决定了 CSS 预处理器的主要目标：提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。</p><hr><p>这篇文章不打算继续将 LESS、SASS 等的嵌套、变量等语法规则。一来这些内容非一篇文章讲得清（我懒），再者看官方文档是最好的入门方式，同时像上面百度EFE的文档比我写肯定高到不知道哪里去了。<br>那么我为什么会将 CSS 预处理和 优先级 放在同一篇文章写呢。也是面试官连续问的这俩个问题（真的很基础了，对我这种转行前端新人十分照顾），再者其实两者有一些联系，CSS 预编译也是在变相解决 优先级 的问题，因为我们需要完美利用优先级，所以我们在写 CSS 时往往选择器需要十分详细，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div&#123;&#125;</span><br><span class="line">div&gt;ul&#123;&#125;</span><br><span class="line">div&gt;ul&gt;li&#123;&#125;</span><br><span class="line">div&gt;ul&gt;li&gt;a&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>本着 Dry 宗旨，CSS 预编译的嵌套规则就是为了解决优先级啊。</p><hr><p>本文仅供个人学习使用</p>]]></content:encoded>
      
      <comments>http://adashuai5.com/2018/12/20/%E4%BC%98%E5%85%88%E7%BA%A7-%E5%92%8C-CSS-%E9%A2%84%E5%A4%84%E7%90%86/#disqus_thread</comments>
    </item>
    
    <item>
      <title>浅谈JS继承</title>
      <link>http://adashuai5.com/2018/11/02/%E6%B5%85%E8%B0%88JS%E7%BB%A7%E6%89%BF/</link>
      <guid>http://adashuai5.com/2018/11/02/%E6%B5%85%E8%B0%88JS%E7%BB%A7%E6%89%BF/</guid>
      <pubDate>Fri, 02 Nov 2018 12:38:27 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;什么是继承&quot;&gt;&lt;a href=&quot;#什么是继承&quot; class=&quot;headerlink&quot; title=&quot;什么是继承&quot;&gt;&lt;/a&gt;什么是继承&lt;/h1&gt;&lt;p&gt;根据维基百科解释，可以简单概括为：&lt;br&gt;继承是类与类之间的关系，其作用是使得子类具有父类别的各种属性和方法。&lt;/p
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h1><p>根据维基百科解释，可以简单概括为：<br>继承是类与类之间的关系，其作用是使得子类具有父类别的各种属性和方法。</p><h1 id="JS-里的原型继承模型"><a href="#JS-里的原型继承模型" class="headerlink" title="JS 里的原型继承模型"></a>JS 里的原型继承模型</h1><p>JS：不好意思，我没有类。（即使是ES6中的类也是语法糖）<br>JavaScript 是基于原型实现面向对象的，那么在JS中，面向对象概念中的继承自然也是基于原型。</p><blockquote><p>当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（object ）都有一个私有属性（称之为[[prototype]]）指向它的原型对象（<strong>prototype</strong>）。该原型对象也有一个自己的原型对象 ，层层向上直到一个对象的原型对象为 <code>null</code>。根据定义，<code>null</code> 没有原型，并作为这个<strong>原型链</strong>中的最后一个环节。</p></blockquote><blockquote><p>几乎所有 JavaScript 中的对象都是位于原型链顶端的 <strong>Object</strong> 的实例。</p></blockquote><p>有关原型之前写过博客<a href="https://www.jianshu.com/p/93441c4e8f48" target="_blank" rel="noopener">JavaScript原型和原型链</a>，对理解下面内容有帮助。<br>虽然没有传统语言意义上的类，但是 JS语言 使用构造函数生成对象，实现面向对象程序设计。</p><h1 id="说了这么多，JS-中的继承到底是什么？"><a href="#说了这么多，JS-中的继承到底是什么？" class="headerlink" title="说了这么多，JS 中的继承到底是什么？"></a>说了这么多，JS 中的继承到底是什么？</h1><p><strong>可以简单理解为：两次的原型搜索就是继承。<br>数组 a 从 Array 中原型搜索到 toString 属性，只是实例属性；a 从 Array 中原型搜索到 （Array 从 Object 中原型搜索到的）valueOf 属性，可以称为继承。</strong></p><p>接下来我们用代码实现一下继承</p><h2 id="1-使用-prototype-实现继承"><a href="#1-使用-prototype-实现继承" class="headerlink" title="1. 使用 prototype 实现继承"></a>1. 使用 prototype 实现继承</h2><p><strong>prototype 的作用：为构造函数内添加实例对象之间的共有属性</strong></p><p><strong>明确 JS 内的继承</strong><br>以下面代码为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 构造一个 人类</span><br><span class="line">function Human(name)&#123;</span><br><span class="line">  this.name = name</span><br><span class="line">&#125;</span><br><span class="line">// 给所有 人类 添加一个 跑 的共有属性</span><br><span class="line">Human.prototype.run = function()&#123;</span><br><span class="line">  console.log(&quot;我叫&quot;+this.name+&quot;，我在跑&quot;)</span><br><span class="line">  return undefined</span><br><span class="line">&#125;</span><br><span class="line">// 构造一个 男人类</span><br><span class="line">function Man(name)&#123;</span><br><span class="line">  Human.call(this, name)</span><br><span class="line">  this.gender = &apos;男&apos;</span><br><span class="line">&#125;</span><br><span class="line">// 所有 男人 都有好战属性</span><br><span class="line">Man.prototype.fight = function()&#123;</span><br><span class="line">  console.log(&apos;糊你熊脸&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-c56b1f3dafb9ff8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到名为 ada 的人只有 name、gender 和fight 这些 Man 构造函数里面含有的属性，而没有我们希望的 Human 应该有的 run 的属性。<br><strong>目标：假如我们有方法让 ada 有了 Man 里面没有的 run 属性，即我们自己实现了 Man 继承 Human 的过程。</strong><br>根据我原型知识的博客里面的内容我们知道，我们可以直接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Man.prototype.__proto__ = Human.prototype</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-3707e4361a656afb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到 Man 指向了 Human 而不是直接指向 Object，ada2 继承了来自 Human 的 run 属性</p><p><strong>但是在实际编程过程中直接操作 <strong> proto </strong> 这个非标准但许多浏览器（IE不支持）实现的属性是不规范的。</strong></p><p>那怎么办？<br>new 可不可以？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Man.prototype = new Human()</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-4f15ba95a00b7a81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>直接用上述代码不行，因为在 new 的过程中，虽然new 内部实现了 <code>Man.prototype.__proto__ = Human.prototype</code> 这一个过程，但是由于 new 同时会在内部执行构造函数，而在执行过程中我们未传 name，因此上图中 Human 的 name 属性显示 undefined</strong></p><p>那么我们只要避免这个过程中 Human 执行就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = function()&#123;&#125;</span><br><span class="line">a.prototype = Human.prototype</span><br><span class="line">Man.prototype = new a()</span><br></pre></td></tr></table></figure></p><p>通过上面三行代码，即实现了没有内部执行空函数的 new</p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-c3c89ccc7f8d8aaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="2-ES6-实现继承"><a href="#2-ES6-实现继承" class="headerlink" title="2. ES6 实现继承"></a>2. ES6 实现继承</h2><p>上面代码的 ES6 版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// ES6 写法</span><br><span class="line">class Human&#123;</span><br><span class="line">     constructor(name)&#123;</span><br><span class="line">         this.name = name</span><br><span class="line">     &#125;</span><br><span class="line">     run()&#123;</span><br><span class="line">         console.log(&quot;我叫&quot;+this.name+&quot;，我在跑&quot;)</span><br><span class="line">         return undefined</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> class Man extends Human&#123; // extends 实现上述继承过程</span><br><span class="line">     constructor(name)&#123;</span><br><span class="line">         super(name) // 调用构造函数:&apos;超类&apos;</span><br><span class="line">         this.gender = &apos;男&apos;</span><br><span class="line">     &#125;</span><br><span class="line">     fight()&#123;</span><br><span class="line">         console.log(&apos;糊你熊脸&apos;)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-f81f6522e88774a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>文章开头已经提到， ES6 的 class 是语法糖，其实质就是函数，而上述用 class 实现继承的过程，还是基于原型链（和 ES5 的是不是完全一致）</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>JS 继承的原型写法相对 ES6 的写法看上去似乎更复杂，但是事实上更好理解；class 的写法更符合面向对象编程的思维，由于是语法糖因而自然写法简便，但其有一定局限性。</p><blockquote><p>原型继承模型本身实际上比经典模型更强大</p></blockquote><hr><p>感谢阅读<br>本文仅供个人学习使用</p><p>部分参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">继承与原型链</a></p>]]></content:encoded>
      
      <comments>http://adashuai5.com/2018/11/02/%E6%B5%85%E8%B0%88JS%E7%BB%A7%E6%89%BF/#disqus_thread</comments>
    </item>
    
    <item>
      <title>正则表达式速记</title>
      <link>http://adashuai5.com/2018/10/28/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%80%9F%E8%AE%B0/</link>
      <guid>http://adashuai5.com/2018/10/28/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%80%9F%E8%AE%B0/</guid>
      <pubDate>Sun, 28 Oct 2018 06:15:51 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;如何学习：&lt;a href=&quot;https://luke0922.gitbooks.io/learnregularexpressionin30m
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如何学习：<a href="https://luke0922.gitbooks.io/learnregularexpressionin30minutes/content/chapter8.html" target="_blank" rel="noopener">30分钟入门正则表达式</a><br><a href="https://www.regexpal.com/" target="_blank" rel="noopener">工具</a><br>本文参（zhao）考（chao）<a href="https://wangdoc.com/javascript/stdlib/regexp.html" target="_blank" rel="noopener">RegExp 对象</a>，该笔记只为速查</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>正则表达式（regular expression）是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象，其体系参照 Perl 5 建立。</p><h1 id="创建正则表达式的方法"><a href="#创建正则表达式的方法" class="headerlink" title="创建正则表达式的方法"></a>创建正则表达式的方法</h1><ol><li><p>使用一个正则表达式字面量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var re = /xxx/</span><br></pre></td></tr></table></figure></li><li><p>调用 RegExp 对象的构造函数</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var re = new RegExp(&apos;xxx&apos;)</span><br></pre></td></tr></table></figure><p>两种方法主要区别是：第一种方法在引擎编译代码时，就会新建正则表达式，第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观，所以实际应用中，基本上都采用字面量定义正则表达式。</p><h1 id="正则表达式的实例属性"><a href="#正则表达式的实例属性" class="headerlink" title="正则表达式的实例属性"></a>正则表达式的实例属性</h1><p>分为两类</p><ol><li>修饰符（只读）<br>RegExp.prototype.ignoreCase：返回一个布尔值，表示是否设置了i修饰符。用于忽略字符串大小写。<br>RegExp.prototype.global：返回一个布尔值，表示是否设置了g修饰符。用于全局匹配。<br>RegExp.prototype.multiline：返回一个布尔值，表示是否设置了m修饰符。用于设置匹配为多行模式。</li><li>其他属性<br>RegExp.prototype.lastIndex：返回一个数值，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义，详细介绍请看后文。<br>RegExp.prototype.source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。</li></ol><h1 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h1><h2 id="1-RegExp-prototype-test"><a href="#1-RegExp-prototype-test" class="headerlink" title="1. RegExp.prototype.test()"></a>1. RegExp.prototype.test()</h2><p>test 方法返回布尔值，表示当前模式是否能匹配参数字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/a/.test(&apos;and&apos;) // true</span><br></pre></td></tr></table></figure></p><h2 id="2-RegExp-prototype-exec"><a href="#2-RegExp-prototype-exec" class="headerlink" title="2. RegExp.prototype.exec()"></a>2. RegExp.prototype.exec()</h2><p>exec方法，用来返回匹配结果<br>如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回null<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/a/.exec(&apos;adbca&apos;)</span><br></pre></td></tr></table></figure></p><p>如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的length属性等于组匹配的数量再加1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.match()：返回一个数组，成员是所有匹配的子字符串。</span><br><span class="line">String.prototype.search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。</span><br><span class="line">String.prototype.replace()：按照给定的正则表达式进行替换，返回替换后的字符串。</span><br><span class="line">String.prototype.split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。</span><br></pre></td></tr></table></figure></p><hr><h1 id="字面量字符和元字符"><a href="#字面量字符和元字符" class="headerlink" title="字面量字符和元字符"></a>字面量字符和元字符</h1><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><ol><li>点字符（.)<br>匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。</li><li><p>位置字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^ 表示字符串的开始位置</span><br><span class="line">$ 表示字符串的结束位置</span><br></pre></td></tr></table></figure></li><li><p>选择符（|）<br>表示“或关系”</p></li><li>转义符<br>匹配元字符本身可以在它们前面加反斜杠<br>构造函数需要两次转义</li><li>特殊字符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。</span><br><span class="line">[\b] 匹配退格键(U+0008)，不要与\b混淆。</span><br><span class="line">\n 匹配换行键。</span><br><span class="line">\r 匹配回车键。</span><br><span class="line">\t 匹配制表符 tab（U+0009）。</span><br><span class="line">\v 匹配垂直制表符（U+000B）。</span><br><span class="line">\f 匹配换页符（U+000C）。</span><br><span class="line">\0 匹配null字符（U+0000）。</span><br><span class="line">\xhh 匹配一个以两位十六进制数（\x00-\xFF）表示的字符。</span><br><span class="line">\uhhhh 匹配一个以四位十六进制数（\u0000-\uFFFF）表示的 Unicode 字符。</span><br></pre></td></tr></table></figure></li></ol><h1 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h1><p>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[^xyz] 表示x、y、z之中任选一个匹配。</p><ol><li>脱字符（^）：需在字符类第一位<br>表示除了字符类之中的字符，其他字符都可以匹配。只有[^]，就表示匹配一切字符，包括换行符。相比之下，点号作为元字符（.）是不包括换行符的。</li><li>连字符（-）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0-9.,]</span><br><span class="line">[0-9a-fA-F]</span><br><span class="line">[a-zA-Z0-9-]</span><br><span class="line">[1-31] // 不代表1到31，只代表1到3</span><br></pre></td></tr></table></figure></li></ol><h1 id="预定义模式：某些常见模式的简写方式"><a href="#预定义模式：某些常见模式的简写方式" class="headerlink" title="预定义模式：某些常见模式的简写方式"></a>预定义模式：某些常见模式的简写方式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\d 匹配0-9之间的任一数字，相当于[0-9]。</span><br><span class="line">\D 匹配所有0-9以外的字符，相当于[^0-9]。</span><br><span class="line">\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。</span><br><span class="line">\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。</span><br><span class="line">\s 匹配空格（包括换行符、制表符、空格符等），相等于[ \t\r\n\v\f]。</span><br><span class="line">\S 匹配非空格的字符，相当于[^ \t\r\n\v\f]。</span><br><span class="line">\b 匹配词的边界。</span><br><span class="line">\B 匹配非词边界，即在词的内部</span><br></pre></td></tr></table></figure><h1 id="重复类"><a href="#重复类" class="headerlink" title="重复类"></a>重复类</h1><p>模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。</p><h1 id="量词符：设定某个模式出现的次数"><a href="#量词符：设定某个模式出现的次数" class="headerlink" title="量词符：设定某个模式出现的次数"></a>量词符：设定某个模式出现的次数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? 问号表示某个模式出现0次或1次，等同于&#123;0, 1&#125;。</span><br><span class="line">* 星号表示某个模式出现0次或多次，等同于&#123;0,&#125;。</span><br><span class="line">+ 加号表示某个模式出现1次或多次，等同于&#123;1,&#125;。</span><br></pre></td></tr></table></figure><h1 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a>贪婪模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;aaa&apos;;</span><br><span class="line">s.match(/a+/) // [&quot;aaa&quot;]</span><br></pre></td></tr></table></figure><p>贪婪模式改为非贪婪模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。</span><br><span class="line">+?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。</span><br></pre></td></tr></table></figure></p><h1 id="字符串去空格-replace"><a href="#字符串去空格-replace" class="headerlink" title="字符串去空格(replace)"></a>字符串去空格(replace)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;  #id div.class  &apos;;</span><br><span class="line">str.trim() // &quot;#id div.class&quot;</span><br><span class="line">str.replace(/^\s+|\s+$/g, &apos;&apos;) // &quot;#id div.class&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$&amp;：匹配的子字符串。</span><br><span class="line">$`：匹配结果前面的文本。</span><br><span class="line">$’：匹配结果后面的文本。</span><br><span class="line">$n：匹配成功的第n组内容，n是从1开始的自然数。</span><br><span class="line">$$：指代美元符号$。</span><br></pre></td></tr></table></figure><p>多多练习吧</p><hr><p>本文仅供个人学习使用</p>]]></content:encoded>
      
      <comments>http://adashuai5.com/2018/10/28/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%80%9F%E8%AE%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>理解虚拟 DOM</title>
      <link>http://adashuai5.com/2018/09/27/%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F-DOM/</link>
      <guid>http://adashuai5.com/2018/09/27/%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F-DOM/</guid>
      <pubDate>Thu, 27 Sep 2018 13:10:41 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;DOM-和-Virtual-DOM&quot;&gt;&lt;a href=&quot;#DOM-和-Virtual-DOM&quot; class=&quot;headerlink&quot; title=&quot;DOM 和 Virtual DOM&quot;&gt;&lt;/a&gt;DOM 和 Virtual DOM&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;DO
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="DOM-和-Virtual-DOM"><a href="#DOM-和-Virtual-DOM" class="headerlink" title="DOM 和 Virtual DOM"></a>DOM 和 Virtual DOM</h1><p><strong>DOM：Document Object Model 把文档变成对象的模型<br>在没有 DOM 之前，JavaScript 想要操作页面（文档）内的元素比较麻烦，于是有了 DOM API 把文档变成对象的模型，可以通过操作这些 API，直接操作元素，而不需要经过麻烦的遍历等基本操作。有了 DOM 写代码的人是舒服了（当然我们知道 DOM 也比较麻烦），但是事实上它的速度自然没有原生 js 的对象来得快。<br>问题：在需要操作大量页面元素的时候，每当发生更改，有什么办法能够快速生成新页面？<br>你可以很快想到用模版引擎重新渲染整个视图，而这样会产生很多问题，首要问题就是慢。DOM 内部含有大量数据结构，而我们有时只对其中一部分元素内容进行增删改查，但却需要对整个页面进行重复渲染。<br>方法：通过创建与 DOM 的数据结构映射的 Virtual DOM 虚拟数据结构，我们只操作虚拟数据结构，先比较虚拟 DOM 的异同，再将最终操作结果反应到 真实 DOM 中。<br>在整个过程中，DOM 只操作了一次，其他改变的操作，我们都通过操作虚拟 DOM：当页面元素需要发生变化，原本我们需要通过 DOM 操作，重新渲染页面，而现在，我们只需要操作虚拟 DOM ，由虚拟 DOM 对比之前操作，把页面变化部分反馈给 DOM，此时 DOM 只需要渲染变化的一部分，不用再次渲染整个页面，大大提高效率和性能。</strong></p><p><code>Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）</code></p><h1 id="过程实现"><a href="#过程实现" class="headerlink" title="过程实现"></a>过程实现</h1><p>文档界面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;./v-dom.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个 VNode 类</span><br><span class="line">class VNode &#123;</span><br><span class="line">    constructor(tag, children, text) &#123;</span><br><span class="line">        this.tag = tag</span><br><span class="line">        this.children = children</span><br><span class="line">        this.text = text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123; // render 方法，创建子元素</span><br><span class="line">        if (this.tag === &apos;#text&apos;) &#123;</span><br><span class="line">            return document.createTextNode(this.text)</span><br><span class="line">        &#125;</span><br><span class="line">        let el = document.createElement(this.tag)</span><br><span class="line">        this.children.forEach(vChild =&gt; &#123;</span><br><span class="line">            el.appendChild(vChild.render())</span><br><span class="line">        &#125;)</span><br><span class="line">        return el</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// v 构造函数，判断子元素类型</span><br><span class="line">function v(tag, children, text) &#123;</span><br><span class="line">    if (typeof children === &apos;string&apos;) &#123;</span><br><span class="line">        text = children</span><br><span class="line">        children = []</span><br><span class="line">    &#125;</span><br><span class="line">    return new VNode(tag, children, text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let vNode = v(&apos;div&apos;, [</span><br><span class="line">    v(&apos;p&apos;, [</span><br><span class="line">        v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;Ada&apos;)])</span><br><span class="line">    ]),</span><br><span class="line">    v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;shuai&apos;)])</span><br><span class="line">])</span><br><span class="line">const root = document.querySelector(&apos;#root&apos;)</span><br><span class="line">root.appendChild(vNode.render())</span><br></pre></td></tr></table></figure><p>通过上述代码，我们构建了一个简单的虚拟 DOM 树，可以通过它构建一个真正的 DOM 树，渲染到页面中<br><img src="https://upload-images.jianshu.io/upload_images/7094266-762ab26eabd2e04e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>精髓：通过对比新旧虚拟 DOM 树，其原生对象判断页面增删改查了哪些部分，而后单独渲染差异部分。没有这个 patchElement 就失去了虚拟 DOM 的意义，和原始 DOM 效果无异了</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function patchElement(parent, newVNode, oldVNode, index = 0) &#123;</span><br><span class="line">    if (!oldVNode) &#123;</span><br><span class="line">        parent.appendChild(newVNode.render())</span><br><span class="line">    &#125; else if (!newVNode) &#123;</span><br><span class="line">        parent.removeChild(parent.childNodes[index])</span><br><span class="line">    &#125; else if (newVNode.tag !== oldVNode.tag || newVNode.text !== oldVNode.text) &#123;</span><br><span class="line">        parent.replaceChild(newVNode.render(), parent.childNodes[index])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (let i = 0; i &lt; newVNode.children.length || i &lt; oldVNode.children.length; i++) &#123;</span><br><span class="line">            patchElement(parent.childNodes[index], newVNode.children[i], oldVNode.children[i], i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然，上述只是简单的算法判断逻辑，但是也能让我们理解其相应过程和原理。</p><p>整个状态变更的过程如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 1. 构建虚拟DOM</span><br><span class="line">let vNode = v(&apos;div&apos;, [</span><br><span class="line">    v(&apos;p&apos;, [</span><br><span class="line">        v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;Ada&apos;)])</span><br><span class="line">    ]),</span><br><span class="line">    v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;shuai&apos;)])</span><br><span class="line">])</span><br><span class="line">// 3. 生成新的虚拟DOM</span><br><span class="line">let vNode1 = v(&apos;div&apos;, [</span><br><span class="line">    v(&apos;p&apos;, [</span><br><span class="line">        v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;Ada&apos;)])</span><br><span class="line">    ]),</span><br><span class="line">    v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;shuai&apos;)]),</span><br><span class="line">    v(&apos;p&apos;, [v(&apos;#text&apos;, &apos;upload&apos;)])</span><br><span class="line">])</span><br><span class="line">// 2. 通过虚拟DOM构建真正的DOM</span><br><span class="line">const root = document.querySelector(&apos;#root&apos;)</span><br><span class="line">patchElement(root, vNode)</span><br><span class="line">var n = 0</span><br><span class="line">// 4. 比较两次虚拟DOM树的不同，在真正的DOM元素上应用变更</span><br><span class="line">document.querySelector(&apos;.btn&apos;).onclick = function () &#123;</span><br><span class="line">    if (n % 2 == 0) &#123;</span><br><span class="line">        patchElement(root, vNode1, vNode)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        patchElement(root, vNode, vNode1)</span><br><span class="line">    &#125;</span><br><span class="line">    n += 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>本文仅供个人学习使用</p><hr><p>主要参考：<a href="https://github.com/livoras/blog/issues/13" target="_blank" rel="noopener">深度剖析：如何实现一个 Virtual DOM 算法</a></p>]]></content:encoded>
      
      <comments>http://adashuai5.com/2018/09/27/%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F-DOM/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HTTP 学习之 Cookie</title>
      <link>http://adashuai5.com/2018/09/16/HTTP-%E5%AD%A6%E4%B9%A0%E4%B9%8B-Cookie/</link>
      <guid>http://adashuai5.com/2018/09/16/HTTP-%E5%AD%A6%E4%B9%A0%E4%B9%8B-Cookie/</guid>
      <pubDate>Sun, 16 Sep 2018 10:43:31 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Cookie：&quot;&gt;&lt;a href=&quot;#Cookie：&quot; class=&quot;headerlink&quot; title=&quot;Cookie：&quot;&gt;&lt;/a&gt;Cookie：&lt;/h2&gt;&lt;p&gt;今天我们要说的当然不是甜品，而是在 HTTP 协议中使用到的 Cookie 知识&lt;br&gt;&lt;code&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Cookie："><a href="#Cookie：" class="headerlink" title="Cookie："></a>Cookie：</h2><p>今天我们要说的当然不是甜品，而是在 HTTP 协议中使用到的 Cookie 知识<br><code>HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</code></p><p>我们知道，服务器和客户端（浏览器）之间通过 HTTP 发送请求和响应来交流。<br>但是 HTTP 是<a href="https://en.wikipedia.org/wiki/Stateless_protocol" target="_blank" rel="noopener">无状态协议</a>：这样做当然能够减少服务器负担，服务器不必记录每一次请求和响应的状态，但这严重阻碍了<a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E4%BA%92%E5%BC%8FWeb%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F" title="交互式Web应用程序" target="_blank" rel="noopener">交互式Web应用程序</a>的实现。</p><p><strong>所以就有了 Cookie 技术：在请求和响应的报文中写入 Cookie 信息来控制客户端状态。</strong></p><ul><li>服务器通过 Set-Cookie 响应头设置 Cookie</li><li>浏览器得到 Cookie 之后，每次请求都要带上 Cookie</li><li>服务器发现并读取 Cookie 就知道对应客户端的状态信息</li></ul><p>Cookie主要用于以下三个方面：</p><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><p><strong>通过 HTTP 协议和 Cookie 技术的协同作用，服务器与客户端之间就可以既快速（HTTP 无状态）又可控（Cookie 有状态）得请求和响应并交互了。<br>当然，由于 Cookie 的安全性等问题，有了 Session（服务器的一小块内存）本文不涉及</strong></p><h2 id="在-node-js-服务端中设置响应头的-Set-Cookie（以用户的-email-为例）代码示例-API-详情"><a href="#在-node-js-服务端中设置响应头的-Set-Cookie（以用户的-email-为例）代码示例-API-详情" class="headerlink" title="在 node.js 服务端中设置响应头的 Set Cookie（以用户的 email 为例）代码示例 API 详情"></a>在 node.js 服务端中设置响应头的 Set Cookie（以用户的 email 为例）代码示例 <a href="https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_response_setheader_name_value" target="_blank" rel="noopener">API 详情</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(&apos;Set-Cookie&apos;,`sign_in_email = $&#123;email&#125;`)</span><br></pre></td></tr></table></figure><p>(这是我写的关于登录注册 demo 里登录请求成功的服务端响应 Cookie 内容部分，完整的代码有兴趣可以看我 <a href="https://github.com/Adashuai5/node-demo/tree/master/cookie-demo" target="_blank" rel="noopener">github</a>，有关 node.js 搭建简单的服务器的内容可以看我相关博客)</p><p>如图当 <a href="mailto:1@ada.com" target="_blank" rel="noopener">1@ada.com</a> 用户发送登录请求成功，服务器返回响应的响应头（Response Headers）内出现 Set - Cookie <img src="https://upload-images.jianshu.io/upload_images/7094266-fdff2ea48f36c28e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">其他页面（只要是同源域名）都将带上 Cookie 信息（这里我们并没有设置其他内容）<img src="https://upload-images.jianshu.io/upload_images/7094266-341585400a01ecf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>设置多个 Cookies<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(&apos;Set-Cookie&apos;, [`sign_in_email = $&#123;email&#125;`, &apos;language=javascript&apos;]);</span><br></pre></td></tr></table></figure></p><p>在开发者工具里的 Application 界面里有 Cookies 我们可以随意设置其 cookie <img src="http://upload-images.jianshu.io/upload_images/7094266-637c2da4867f4daf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="Set-Cookie-字段还可以附加-Cookie-的属性-MDN"><a href="#Set-Cookie-字段还可以附加-Cookie-的属性-MDN" class="headerlink" title="Set-Cookie 字段还可以附加 Cookie 的属性 MDN"></a>Set-Cookie 字段还可以附加 Cookie 的属性 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie" target="_blank" rel="noopener">MDN</a></h2><p><img src="https://upload-images.jianshu.io/upload_images/7094266-479fc61fdf79ed54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="常用属性"><br><strong>多个属性之间用 ; 连接，下面代码添加了 Secure 和 HttpOnly 属性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(&apos;Set-Cookie&apos;,`sign_in_email = $&#123;email&#125;;Secure;HttpOnly`)</span><br></pre></td></tr></table></figure></p><p><strong>可以通过设置 Set-Cookie 的 Max-Age 属性 和 Expires 属性</strong><br>以 node.js 为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(&apos;Set-Cookie&apos;,&apos; Max-Age=1000; Expires=Sun, 16 Sep 2018 10:05:35 GMT&apos;)</span><br></pre></td></tr></table></figure></p><p>上面代码设置了响应头在1000秒后 cookie 失效，同时指定了 Expires 和Max-Age，那么Max-Age的值将优先生效</p><p>关闭 session（会话）即可删除内存 Cookie；上述过期时间达到则会删除硬盘 Cookie，因此可以通过设置过期时间删除 Cookie<br>我们还可以通过手动清除浏览器 Cookie 及缓存删除 cookie</p><p><strong>相关内容可以参考<br><a href="http://javascript.ruanyifeng.com/bom/cookie.html#toc4" target="_blank" rel="noopener">Cookie 的属性</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" target="_blank" rel="noopener">HTTP Cookie</a><br><a href="https://zh.wikipedia.org/wiki/Cookie" target="_blank" rel="noopener">Cookie-wikipedia</a><br>同时这也是本文参考内容，另外还参考了 《图解HTTP》相关章节</strong></p><hr><p>本文仅供个人学习使用</p>]]></content:encoded>
      
      <comments>http://adashuai5.com/2018/09/16/HTTP-%E5%AD%A6%E4%B9%A0%E4%B9%8B-Cookie/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CSS常用布局 续篇</title>
      <link>http://adashuai5.com/2018/09/10/CSS%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80-%E7%BB%AD%E7%AF%87/</link>
      <guid>http://adashuai5.com/2018/09/10/CSS%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80-%E7%BB%AD%E7%AF%87/</guid>
      <pubDate>Mon, 10 Sep 2018 02:32:52 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;几个月前初学 CSS布局，写了一篇关于 &lt;a href=&quot;https://www.jianshu.com/p/59c9477816b8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSS常用布局学习&lt;/a&gt; 的博客，介绍了一些传统的依靠 position
        
      
      </description>
      
      <content:encoded><![CDATA[<p>几个月前初学 CSS布局，写了一篇关于 <a href="https://www.jianshu.com/p/59c9477816b8" target="_blank" rel="noopener">CSS常用布局学习</a> 的博客，介绍了一些传统的依靠 position 和 float 等实现简单的布局方式的例子，这些布局只能简单得实现基本功能，十分不便。<br>今天，作为引申，我们用同样例子，来使用上篇中简单提到的 flex 布局的方案实现。与此同时，我将推荐最近学习的 grid 布局，它十分强大，可以方便得解决各种布局方案，且十分便于理解。</p><h3 id="Flex-实现左中右布局"><a href="#Flex-实现左中右布局" class="headerlink" title="Flex 实现左中右布局"></a>Flex 实现左中右布局</h3><p>主要是在父元素中使用以下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">display: flex;</span><br><span class="line">flex-direction:row;</span><br></pre></td></tr></table></figure></p><p>相对于传统布局，是不是简便得多<img src="https://upload-images.jianshu.io/upload_images/7094266-f0d2834c90f115a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Flex 左中右"></p><h3 id="Flex-实现垂直居中"><a href="#Flex-实现垂直居中" class="headerlink" title="Flex 实现垂直居中"></a>Flex 实现垂直居中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display: flex;</span><br><span class="line">justify-content:center;</span><br><span class="line">align-items:center;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/7094266-42ece01a2af28519.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Flex 垂直居中"></p><p>可以看到 flex 布局十分方便<br>想要了解更多 flex 布局相关技巧可以阅读阮大大 <a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">博客</a> 当然你可以看 MDN</p><p>前面介绍的都是一维布局，但是在复杂的二维布局方面，无疑是为解决布局而创建的 CSS 网格布局更为专业<br>学习网格布局事实上是学习对应英文的过程，所以英语好真的很有优势</p><h3 id="Grid-布局实现左中右"><a href="#Grid-布局实现左中右" class="headerlink" title="Grid 布局实现左中右"></a>Grid 布局实现左中右</h3><p>虽然有点大材小用，但是我们是为了和前面的布局方法做对比<br>你只需用两行代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">display: grid;</span><br><span class="line">grid-template-columns: 30% 40% 30%;</span><br></pre></td></tr></table></figure></p><p>grid 布局的代码更省，子元素不需要各自设定，直接在父元素上设定了<img src="https://upload-images.jianshu.io/upload_images/7094266-beb5abb9ff73f97d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Grid 左中右">当然这里的子元素要与对应的格子相配，即 30% 40% 30% 对应的是 div.container 里面的顺序</p><h3 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h3><p>这里的 fr 为分数单位<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display: grid;</span><br><span class="line">grid-template-columns: 1fr 1fr 1fr; // 3列均分</span><br><span class="line">grid-template-rows: 1fr 1fr 1fr; // 3行均分</span><br></pre></td></tr></table></figure></p><p>通过上面代码实现了一个3*3的网格<br>可以通过下面代码选择对应网格，并添加属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grid-column: 1; // or 2 or 3</span><br><span class="line">grid-row: 1; // or 2 or 3</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-fe08051eb5cf5c1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网格布局示例"></p><hr><p>以上只是 flex 布局和 grid 布局的小例子和基本用法<br>想要了解更多 grid 相关内容可以看这篇 <a href="https://www.jianshu.com/p/d183265a8dad" target="_blank" rel="noopener">博客</a><br>通过 flex 和 grid 布局配合使用，基本上可以解决所有 CSS 布局问题</p><p>本文仅供个人学习使用</p>]]></content:encoded>
      
      <comments>http://adashuai5.com/2018/09/10/CSS%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80-%E7%BB%AD%E7%AF%87/#disqus_thread</comments>
    </item>
    
    <item>
      <title>AJAX 是什么鬼</title>
      <link>http://adashuai5.com/2018/09/04/AJAX-%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC/</link>
      <guid>http://adashuai5.com/2018/09/04/AJAX-%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC/</guid>
      <pubDate>Tue, 04 Sep 2018 12:57:25 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;之前写了一篇博客&lt;a href=&quot;https://www.jianshu.com/p/2a2fe02917e7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;理解JSONP 上&lt;/a&gt;关于AJAX出现之前如何发请求&lt;br&gt;简单回顾一下：&lt;/p&gt;
&lt;h4 i
        
      
      </description>
      
      <content:encoded><![CDATA[<p>之前写了一篇博客<a href="https://www.jianshu.com/p/2a2fe02917e7" target="_blank" rel="noopener">理解JSONP 上</a>关于AJAX出现之前如何发请求<br>简单回顾一下：</p><h4 id="1-用-form-可以发请求，缺点是会刷新页面或新开页面"><a href="#1-用-form-可以发请求，缺点是会刷新页面或新开页面" class="headerlink" title="1.用 form 可以发请求，缺点是会刷新页面或新开页面"></a>1.用 form 可以发请求，缺点是会刷新页面或新开页面</h4><p>form发送get请求：<img src="https://upload-images.jianshu.io/upload_images/7094266-8a9a80cde134701d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>输入密码后，点击提交，打开开发者工具可以看到一个get请求，点开找到Request Headers点击<strong>view source</strong> <img src="https://upload-images.jianshu.io/upload_images/7094266-2f497d2ed697fabb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>同样可以用form发送post请求，与get请求区别是post请求没有查询参数<img src="https://upload-images.jianshu.io/upload_images/7094266-2a9955c21d5904d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>post请求的第四部分 password在下面的 Form Data 的<strong>view source</strong> 里<img src="https://upload-images.jianshu.io/upload_images/7094266-c10130216b9836f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="2-用-a-可以发-get-请求，但是也会刷新页面或新开页面"><a href="#2-用-a-可以发-get-请求，但是也会刷新页面或新开页面" class="headerlink" title="2.用 a 可以发 get 请求，但是也会刷新页面或新开页面"></a>2.用 a 可以发 get 请求，但是也会刷新页面或新开页面</h4><p>点击click就发送请求<img src="https://upload-images.jianshu.io/upload_images/7094266-e8ecdf0d63d5c019.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;a id=&quot;ada&quot; href=&quot;/ada&quot;&gt;click&lt;/a&gt;</span><br><span class="line">//运行一个脚本，让网页自己点击（但是依然会刷新页面）</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  ada.click()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h4 id="3-用-img-可以发-get-请求，它不会刷新页面，但是只能以图片的形式展示"><a href="#3-用-img-可以发-get-请求，它不会刷新页面，但是只能以图片的形式展示" class="headerlink" title="3.用 img 可以发 get 请求，它不会刷新页面，但是只能以图片的形式展示"></a>3.用 img 可以发 get 请求，它不会刷新页面，但是只能以图片的形式展示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var image = document.createElement(&apos;img&apos;)</span><br><span class="line">  image.src = &apos;/ada&apos;</span><br><span class="line">  image.onload = function()&#123;</span><br><span class="line">    console.log(&apos;succsee&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  image.onerror = function()&#123;</span><br><span class="line">    console.log(&apos;fail&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/7094266-9b2b91b49a0575b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="4-用-link-可以发-get-请求，但是只能以-CSS、favicon-的形式展示"><a href="#4-用-link-可以发-get-请求，但是只能以-CSS、favicon-的形式展示" class="headerlink" title="4.用 link 可以发 get 请求，但是只能以 CSS、favicon 的形式展示"></a>4.用 link 可以发 get 请求，但是只能以 CSS、favicon 的形式展示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var link = document.createElement(&apos;link&apos;)</span><br><span class="line">  link.rel = &apos;stylesheet&apos;</span><br><span class="line">  link.href = &apos;/ada&apos;</span><br><span class="line">  //需要将link放到页面中才能发送请求</span><br><span class="line">  document.head.appendChild(link)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/7094266-ff9dc05b89603af5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="5-用-script-可以发-get-请求，但是只能以脚本的形式运行"><a href="#5-用-script-可以发-get-请求，但是只能以脚本的形式运行" class="headerlink" title="5.用 script 可以发 get 请求，但是只能以脚本的形式运行"></a>5.用 script 可以发 get 请求，但是只能以脚本的形式运行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var script = document.createElement(&apos;script&apos;)</span><br><span class="line">  script.src = &quot;/ada&quot;</span><br><span class="line">  //需要将script放到页面中才能发送请求</span><br><span class="line">  document.head.appendChild(script)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>当然还有其他方法</p><hr><p>有关AJAX的学习推荐<a href="http://javascript.ruanyifeng.com/bom/ajax.html#toc0" target="_blank" rel="noopener">阮一峰博客</a><br><strong>微软的突破</strong><br>IE 5 率先在 JS 中引入 ActiveX 对象（API），使得 JS 可以直接发起 HTTP 请求。<br>随后 Mozilla、 Safari、 Opera 也跟进了，取名 XMLHttpRequest，并被纳入 W3C 规范<br><strong>AJAX</strong><br>Jesse James Garrett 将如下技术取名叫做 AJAX（Asynchronous JavaScript and XML）：异步的 JavaScript 和 XML<br><strong><em>1.使用 XMLHttpRequest 发请求<br>2.服务器返回 XML 格式的字符串<br>3.JS 解析 XML，并更新局部页面</em></strong></p><h4 id="同样我们用node服务器来尝试一下这三个条件-AJAX"><a href="#同样我们用node服务器来尝试一下这三个条件-AJAX" class="headerlink" title="同样我们用node服务器来尝试一下这三个条件(AJAX)"></a>同样我们用node服务器来尝试一下这三个条件(AJAX)</h4><p>新建html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    hi</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>Node代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;含查询字符串的路径\n&apos; + pathWithQuery)</span><br><span class="line">  if (path === &apos;/&apos;) &#123;</span><br><span class="line">    var string = fs.readFileSync(&apos;./index.html&apos;, &apos;utf8&apos;)</span><br><span class="line">    response.statusCode = 200</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;)</span><br><span class="line">    response.write(string)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125; else&#123;</span><br><span class="line">    response.statusCode = 404</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;)</span><br><span class="line">    response.write(&apos;找不到服务器&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>对于HTTP来说，响应的第四部分始终是string<img src="https://upload-images.jianshu.io/upload_images/7094266-01746a588b0abc36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>在 html 里创建一个button，引入当前目录下的 js 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button id=&quot;myButton&quot;&gt;点我&lt;/button&gt;</span><br><span class="line">    &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p>Node代码//在原Node代码中插入，下同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//注意这里是 /main.js 而不是 ./main.js，因为HTTP请求永远是绝对路径</span><br><span class="line">else if (path === &apos;/main.js&apos;) &#123;</span><br><span class="line">//这里当然是./main.js</span><br><span class="line">    var string = fs.readFileSync(&apos;./main.js&apos;, &apos;utf8&apos;)</span><br><span class="line">    response.statusCode = 200</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/javascript; charset=utf-8&apos;)</span><br><span class="line">    response.write(string)</span><br><span class="line">    response.end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>首先满足1.使用 XMLHttpRequest 发请求</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myButton.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class="line">    let request = new XMLHttpRequest()</span><br><span class="line">    //初始化请求，参数为:method,url,async(异步状态下才是AJAX),user,password(后三个参数一般默认)</span><br><span class="line">    request.open(&apos;GET&apos;, &apos;/ada&apos;)</span><br><span class="line">    request.send()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>2.服务器返回 XML 格式的字符串</strong><br>XML已经不流行了，但是我们依然可以尝试一下<br>找一个一个XML example<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">else if (path === &apos;/ada&apos;) &#123;</span><br><span class="line">    response.statusCode = 200</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/xml; charset=utf-8&apos;)</span><br><span class="line">    response.write(`</span><br><span class="line">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">    &lt;note&gt;</span><br><span class="line">    &lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">    &lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">    &lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">    &lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;`)</span><br><span class="line">    response.end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-d5529f18c6d6d036.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>3.JS 解析 XML，并更新局部页面</strong><br>浏览器是分步下载响应的，一般只要记住 <strong>readyState === 4</strong> 表示请求完成<img src="https://upload-images.jianshu.io/upload_images/7094266-a27d3791360b1d30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以用 <strong>onreadystatechange</strong> 监听 readyState<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">myButton.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class="line">    let request = new XMLHttpRequest()</span><br><span class="line">    request.onreadystatechange = () =&gt; &#123;</span><br><span class="line">        if (request.readyState === 4) &#123;</span><br><span class="line">            console.log(&apos;请求响应都完成了&apos;)</span><br><span class="line"></span><br><span class="line">            if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123;</span><br><span class="line">                console.log(&apos;success&apos;)</span><br><span class="line">                //响应值在300-400之间浏览器会重新发送请求</span><br><span class="line">            &#125; else if (request.status &gt;= 400) &#123;</span><br><span class="line">                console.log(&apos;fail&apos;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //初始化请求，参数为:method,url,async(异步状态下才是AJAX),user,password(后三个参数一般默认)</span><br><span class="line">    request.open(&apos;GET&apos;, &apos;/ada&apos;)</span><br><span class="line">    request.send()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-6159a07fdb534df4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>如果把(path === ‘/ada’){}里改成400  //注意不要改错地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.statusCode = 400</span><br></pre></td></tr></table></figure></p><p>当然会返回 fail，可以看到 readyState 是不受状态码影响的<img src="https://upload-images.jianshu.io/upload_images/7094266-dc4181f8240aa1b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>JS 是可以解析 XML的，但是现在XML已经被JSON取代了，我们可以简单打印出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(request.responseText)</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-beb53639db92273c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><p><a href="https://www.json.org/" target="_blank" rel="noopener">JSON</a><br>JSON是道格拉斯基于JavaScript发明的数据交换语言</p><ul><li>特点：<ul><li></li><li>只有 object、array、string、number、true、false、null 这几种类型</li><li>字符串首尾必须为双引号<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JS         VS         JSON</span><br><span class="line">undefined/symbel      无</span><br><span class="line">null                  null</span><br><span class="line">[&apos;a&apos;,&apos;b&apos;]             [&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">function f()&#123;&#125;        无</span><br><span class="line">&#123;a:b&#125;                 &#123;&quot;a&quot;,&quot;b&quot;&#125;</span><br><span class="line">&apos;hello world&apos;         &quot;hello world&quot;</span><br><span class="line">var a = &#123;&#125;</span><br><span class="line">a.self = a            无法做到&#123;无变量等形式&#125;</span><br><span class="line">&#123;__proto__&#125;           没有原型链</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>用JSON替换XML</strong><br>Node代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">else if (path === &apos;/ada&apos;) &#123;</span><br><span class="line">    response.statusCode = 200</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/xml; charset=utf-8&apos;)</span><br><span class="line">//变XML为JSON，key和value都可以替换成自己喜欢的</span><br><span class="line">    response.write(`</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;note&quot;:&#123;</span><br><span class="line">        &quot;to&quot;: &quot;reader&quot;,</span><br><span class="line">        &quot;from&quot;: &quot;Ada&quot;,</span><br><span class="line">        &quot;heading&quot;: &quot;greet&quot;,</span><br><span class="line">        &quot;content&quot;: &quot;hello word!&quot;</span><br><span class="line">    &#125;`)</span><br><span class="line">    response.end()</span><br></pre></td></tr></table></figure></p><p>js完整代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">myButton.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class="line">    let request = new XMLHttpRequest()</span><br><span class="line">    request.onreadystatechange = () =&gt; &#123;</span><br><span class="line">        if (request.readyState === 4) &#123;</span><br><span class="line">            console.log(&apos;请求响应都完成了&apos;)</span><br><span class="line"></span><br><span class="line">            if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123;</span><br><span class="line">                console.log(&apos;success&apos;)</span><br><span class="line">                console.log(typeof request.responseText)</span><br><span class="line">                console.log(request.responseText)</span><br><span class="line">                let string = request.responseText</span><br><span class="line">                // 把符合 JSON 语法的字符串转换成 JS 对应的值</span><br><span class="line">                let object = window.JSON.parse(string)</span><br><span class="line">                // JSON.parse 是浏览器提供的</span><br><span class="line">                //响应值在300-400之间浏览器会重新发送请求</span><br><span class="line">            &#125; else if (request.status &gt;= 400) &#123;</span><br><span class="line">                console.log(&apos;fail&apos;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //初始化请求，参数为:method,url,async(异步状态下才是AJAX),user,password(后三个参数一般默认)</span><br><span class="line">    request.open(&apos;GET&apos;, &apos;/ada&apos;)</span><br><span class="line">    request.send()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-4f376b146466e10d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><h2 id="同源政策"><a href="#同源政策" class="headerlink" title="同源政策"></a>同源政策</h2><p>同源政策规定，AJAX请求只能发给同源的网址，否则就报错。<br>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。<br>文章开头提到的 form 和 a 等发送请求是没有同源政策的，而AJAX是可以读取响应内容的。</p><h2 id="因此只有-协议-端口-域名-一模一样（同源）才允许发-AJAX-请求"><a href="#因此只有-协议-端口-域名-一模一样（同源）才允许发-AJAX-请求" class="headerlink" title="因此只有 协议+端口+域名 一模一样（同源）才允许发 AJAX 请求"></a><strong>因此只有 协议+端口+域名 一模一样（同源）才允许发 AJAX 请求</strong></h2><h2 id="如何规避同源政策？跨域"><a href="#如何规避同源政策？跨域" class="headerlink" title="如何规避同源政策？跨域"></a>如何规避同源政策？跨域</h2><p>有关JSONP跨域在文章开头提供我的博客举过例子<br>这次我们用 <strong>CORS 跨域</strong></p><h2 id="什么是-CORS-Cross-Origin-Resource-Sharing-跨域资源共享"><a href="#什么是-CORS-Cross-Origin-Resource-Sharing-跨域资源共享" class="headerlink" title="什么是 CORS:Cross-Origin Resource Sharing(跨域资源共享)"></a>什么是 CORS:<strong>Cross-Origin Resource Sharing(跨域资源共享)</strong></h2><p>同样用<a href="https://www.jianshu.com/p/38a72bd0e37d" target="_blank" rel="noopener">理解JSONP 下</a>博客中创建过的网站来举例子<br>首先打开服务器端口<img src="https://upload-images.jianshu.io/upload_images/7094266-49fcd7432b2c7d59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>把请求路径改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.open(&apos;GET&apos;, &apos;http://jack.com:8002/ada&apos;)</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-706af4f9ecdace99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>点击点我<img src="https://upload-images.jianshu.io/upload_images/7094266-7a4b7e5d44756b7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">报错了，因为不是同源，响应完成却得不到任何内容</p><p><strong>解决方法，在Node代码中加入一句</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//允许 http://ada.com:8001 访问我</span><br><span class="line">response.setHeader(&apos;Access-Control-Allow-Origin&apos;,&apos;http://ada.com:8001&apos;)</span><br></pre></td></tr></table></figure></p><p>点击点我，即可向 ada.com:8001 发送请求并返回 jack.com:8002/ada 的响应内容<img src="https://upload-images.jianshu.io/upload_images/7094266-1797c104e4b05d76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>这就是用CORS实现AJAX跨域的过程</p><p>完整代码详见 <a href="https://github.com/Adashuai5/node-demo/tree/master/AJAX-demo" target="_blank" rel="noopener">github</a></p><hr><p>本文仅供个人学习使用</p>]]></content:encoded>
      
      <comments>http://adashuai5.com/2018/09/04/AJAX-%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
